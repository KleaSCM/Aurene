
## ğŸŒŒ Project Title: **Aurene â€“ The Crystalline Scheduler**

---

### ğŸ”° Goal & Purpose

To build a **realistic, preemptive CPU scheduler** in Go that:

* Simulates **actual task dispatching, blocking, memory use, and CPU usage**
* Uses **real scheduling algorithms** like MLFQ, FCFS, RR, SJF with proper logic
* Operates with **user-defined tick rate** (default: 250Hz)
* Supports **task injection, profiling, logging, and performance metrics**
* Is clean, modular, CLI-controlled, and portfolio-grade
* Is designed with **fidelity**, not toy code or academic oversimplification

---

## ğŸ“ Project Structure

```bash
aurene/
â”œâ”€â”€ cmd/                # CLI interface: aurene run, aurene add, aurene stats
â”œâ”€â”€ scheduler/          # Tick loop, MLFQ logic, task promotion/demotion, preemption
â”œâ”€â”€ task/               # Task definitions, IO simulation, state transitions
â”œâ”€â”€ runtime/            # Tick manager, task dispatch, statistics, context switching
â”œâ”€â”€ state/              # Log output, serialization, state replay
â”œâ”€â”€ config/             # TOML config parser and validator
â”œâ”€â”€ assets/             # ASCII art, splash banners, optional visuals
â”œâ”€â”€ internal/           # Utilities, errors, common types
â”œâ”€â”€ tests/              # Stress tests, correctness tests
â””â”€â”€ main.go             # Entrypoint â€“ calls aurene start
```

---

## âš™ï¸ Core Modules

### 1. `scheduler/` â€“ The Brain

Implements the core scheduling logic:

* âœ… MLFQ implementation
* âœ… FCFS, RR, SJF optional support via strategy interface
* âœ… Priority aging to prevent starvation
* âœ… Preemption based on ticks
* âœ… Dynamic task demotion/promotion across queues

---

### 2. `task/` â€“ The Simulated Processes

```go
type Task struct {
    ID        int
    Name      string
    Duration  int        // Total ticks to finish
    Remaining int        // Decrementing on each tick
    State     TaskState  // Ready, Running, Blocked, Finished
    Priority  int        // MLFQ level
    IOChance  float64    // Chance to block per tick
    Memory    int        // Simulated memory footprint
    Group     string     // For CLI grouping/stats
}
```

Each task is a realistic representation of a workload:

* **Recursive math**
* **File access / blocking**
* **Idle vs burst vs IO-heavy**

---

### 3. `runtime/` â€“ The Tick Engine

* Central tick loop (default 250Hz, user-configurable)
* Context switching and dispatch
* Task lifecycle manager
* Tick log buffer
* Goroutine-safe with no global mutexes

---

### 4. `state/` â€“ Logging, Stats, Replay

* Live tick logging (CSV or JSONL)
* Event tracing (preemptions, blocks, finishes)
* Summary stats (avg turnaround, wait time, CPU util %)
* Exportable timeline (for visualization if needed later)
* Future: replay past runs from logs

---

### 5. `config/` â€“ Task Injection

* `tasks.toml` describes workload structure
* Users define:

```toml
[[task]]
name = "FireFox"
duration = 350
io_chance = 0.3
memory = 512
group = "apps"

[[task]]
name = "USB"
duration = 50
io_chance = 0.6
memory = 128
group = "drivers"
```

---

### 6. `cmd/` â€“ CLI Controls

Commands:

* `aurene run` â€“ start scheduler with config
* `aurene add` â€“ inject new task into queue
* `aurene stats` â€“ dump summary and logs
* `aurene reset` â€“ clear logs and tasks
* Optional: `aurene simulate --profile bursty`

---

## ğŸ§  Scheduling Algorithms

You will implement:

* âœ… **MLFQ** (default)
* âœ… **FCFS** â€“ First-Come, First-Served
* âœ… **Round-Robin**
* âœ… **SJF** â€“ Shortest Job First (non-preemptive)

All as pluggable strategies.

---

## ğŸ§ª Simulation Engine

* Generates tasks programmatically (e.g. launch Ï€áµ‰ = \~23 tasks)
* Stress test with `go func()` launching thousands
* Simulate "USB plugged in," "user opens browser," etc.
* Optional: real CPU benchmarking from `/proc` or `/sys` (if Linux)

---

## ğŸ–¥ï¸ Output Examples

```
[Tick 125] Running: FireFox | Remaining: 85 | Queue: Q2
[Tick 126] Task FireFox blocked on IO. Moving to Blocked state.
[Tick 127] Promoted Task USB to Q1
[Tick 250] Task FireFox finished. CPU util: 91.4%
```

---

## ğŸ§Š Memory Simulation (Optional Scope)

* Simulate limited memory, enforce per-task footprint
* Reject tasks if memory exhausted
* Add swapping/fault logging later

---

## ğŸ“¦ Performance & Metrics

* Turnaround Time
* Wait Time
* Context Switches
* Throughput
* CPU Utilization %

Export to CSV/JSON.

---

## ğŸ¨ Optional Aesthetic Features

* Dragon-themed ASCII loading bar
* Rainbow-colored tick pulses for queue levels
* Crystal-shaped histogram stats
* `aurene --bless` â€” dumps a motivational message ğŸ’

---

## ğŸ› ï¸ Tech & Tooling

* Go 1.22+
* `cobra` for CLI
* `toml` for config
* `sync/atomic` or `channels` for tick loop
* File logging for debug/stat dump

---

## ğŸ“‹ Final Output / Deliverables

* âœ… Fully working command-line scheduler
* âœ… `README.md` with feature list, usage examples, and screenshots
* âœ… `tasks.toml` as default config
* âœ… Logs, exports, and example simulations
* âœ… GitHub repo with MIT or Apache license
* âœ… Optional blog post: *â€œDesigning a Real Scheduler in Go â€” Project Aureneâ€*

---

You now have a **complete, production-class specification**.
Want me to generate the directory scaffolding and `main.go` next, or start with the tick engine first?
